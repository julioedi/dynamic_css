/**
 * https://github.com/julioedi/dynamic_css/
 * CustomCssSheet dynamically generates CSS classes based on naming conventions,
 * responsive breakpoints, pseudo-classes, and transform utilities.
 * 
 * Features:
 * - Dynamically creates <style> sheets for different breakpoints.
 * - Supports responsive classes (e.g., `sm:mt-2`, `xl:bg-red`).
 * - Adds utility classes for spacing, sizing, colors, transforms, flex, grid, shadows, etc.
 * - Observes the DOM for new elements or class changes to inject CSS rules automatically.
 */
$observer = new class { scale = window.dynamiCssScale || .25; inited = !1; classNames = {}; classNamesList = new Set; classNamesListAdded = new Set; sizes = (window.sizes ?? [{ code: "xxl", size: 1440 }, { code: "xl", size: 1366 }, { code: "lg", size: 1280 }, { code: "md", size: 1080 }, { code: "sm", size: 540 }, { code: "xs", size: 360 }]).reverse(); colors = window?.dynamicCssColors ?? []; sheets = []; matches = null; matchesCodes = []; constructor() { this.sheets = [null].concat(this.sizes.map((s => s.size))).map((s => { const e = document.createElement("style"); return s && (e.media = `all and (min-width:${s}px)`), document.head.appendChild(e), e })); const s = this.sheets[0]; s.sheet?.insertRule('[class*="grid"]{display:grid}', 0), s.sheet?.insertRule('[class*="flex"]{display:flex}', 1); let e = []; for (let s = 0; s < 32; s++)e.push(`--sp-${s}:${s * this.scale}rem`); e = ":root{" + e.join(";") + "}", s.sheet?.insertRule(e, 2), this.matchesCodes = this.sizes.map((s => s.code)); const t = this.matchesCodes.join("|"); this.matches = new RegExp(`^(${t}):(.*?)$`), this.getTranformRegex(), this.init() } scapeChars(s) { return s.replace(/([\\{}:()*+?.,^$|#\[\]\/])/g, "\\$1") } tranformKeys = ["matrix", "matrix3d", "perspective", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "translate", "translate3d", "translateX", "translateY", "translateZ", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY"]; tranformRegex = /^$/; tranformRegexVariant = /^$/; tranformRegexChilds = /^$/; getTranformRegex() { const s = this.tranformKeys.join("|"); this.tranformRegex = new RegExp(`^(${s})(-[\\w|.|\\%]+)$`, "i"), this.tranformRegexChilds = new RegExp(`-(${s})-([\\w|.|\\%]+)+`, "ig"), this.tranformRegexVariant = new RegExp(`^transform(-(${s})(-[\\w|.|\\%]+)+)+$`, "i") } processTransform(s) { const e = this.scapeChars(s), t = s.match(/^transform-\((--[a-z0-9\-_]+)\)$/i); if (t) { const s = `transform: var(${t[1]})`; return this.classNames[e] = s, this.processClassname(e), this.reponsiveAdd(), !0 } const a = s.match(/^transform-\[(.*?)\]/); if (a) { const s = a[1].trim().replace(/\s+/g, " ").replace(/(;|,)\s+/g, "$1 "); return this.classNames[e] = "transform:" + s, this.processClassname(e), this.reponsiveAdd(), !0 } const r = s.match(this.tranformRegex); if (r) { const s = r[2].replace(/^\-/, "").replace(/\-+/g, ", "); this.classNames[e] = `transform:${r[1]}(${s})`, this.processClassname(e), this.reponsiveAdd() } const i = s.match(this.tranformRegexVariant); if (i) { const s = [...i[1].matchAll(this.tranformRegexChilds)].map((s => `${s[1]}(${s[2].replace(/^\-/, "").replace(/\-+/g, ", ")})`)), t = "transform:" + s.join(" "); return this.classNames[e] = t, this.processClassname(e), this.reponsiveAdd(), !0 } return !1 } gotClassName(s) { const e = [s]; for (; e.length > 0;) { const s = e.pop(); s.classList?.forEach((s => { const e = s.replace(this.pseudo, ""); !this.classNamesList.has(e) || this.classNamesListAdded.has(s) ? this.processTransform(s) : this.processClassname(s) })), s.children && Array.from(s.children).forEach((s => e.push(s))) } } observer() { var s = null, e = []; function t(t) { for (; e.length > 0;) { var a = e.shift(); a && t.gotClassName(a) } s = null } new MutationObserver(function (a) { a.forEach((function (s) { "childList" === s.type && s.addedNodes.forEach((function (s) { 1 === s.nodeType && s.classList.length > 0 && e.push(s) })), "attributes" === s.type && "class" === s.attributeName && e.push(s.target) })), s && clearTimeout(s), s = setTimeout(t, 100, this) }.bind(this)).observe(document.head.parentElement, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["class"] }) } pseudo = /\:(hover|focus|active|visited|link|checked|disabled|empty|valid|invalid|focus-within)$/; processClassname(s) { if (this.classNamesListAdded.has(s)) return; const e = s.match(this.matches), t = s.match(this.pseudo); if (e) { const a = this.matchesCodes.indexOf(e[1]); -1 !== a && this.addClass(s, a + 1, t ? t[1] : null) } else this.addClass(s, 0, t ? t[1] : null) } addClass(s, e = 0, t = null) { const a = s.replace(this.matches, "$2").replace(this.pseudo, ""), r = this.classNames[a] ?? null; if (r && !this.classNamesListAdded.has(s)) { this.classNamesListAdded.add(s); const a = s.replace(/([%\[\]\:])/g, "\\$1"); let i = ""; t ? i += `.${a}:${t}{${r}}` : i = `.${a}{${r}}`; try { this.sheets[e].sheet?.insertRule(i, this.sheets[e].sheet.cssRules.length) } catch (s) { } } } async init() { if (this.inited) return; this.inited = !0; const s = ["inherit", "unset", "initial"];[].concat(s, ["left", "center", "right", "justify", "end", "start"]).forEach((s => { this.classNames[`text-${s}`] = `text-align:${s}` })), ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgrey", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred ", "indigo  ", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgrey", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].forEach((s => { this.classNames[`bg-${s}`] = `background-color:${s}`, this.classNames[`border-${s}`] = `border-color:${s}`, this.classNames[`color-${s}`] = `color:${s}`, this.classNames[`outline-${s}`] = `outline-color:${s}` })), this.colors.forEach((s => { this.classNames[`bg-${s}`] = `background-color:var(--${s})`, this.classNames[`border-${s}`] = `border-color:var(--${s})`, this.classNames[`color-${s}`] = `color:var(--${s})`, this.classNames[`outline-${s}`] = `outline-color:var(--${s})` })), [...s, "absolute", "fixed", "relative", "static", "sticky", "revert", "revert-layer"].forEach((s => { this.classNames[`position-${s}`] = `position:${s}` })); const e = ["width", "height"], t = ["w", "h"]; for (let s = 0; s < 241; s++) { const a = s * this.scale; if (e.forEach(((e, r) => { const i = 0 === r ? "vw" : "vh", l = `max-${t[r]}`, o = `min-${t[r]}`; this.classNames[`${t[r]}-${s}`] = `${e}:${a}rem`, this.classNames[`${l}-${s}`] = `${l}:${a}rem`, this.classNames[`${o}-${s}`] = `${o}:${a}rem`, this.classNames[`${i}-min-${s}`] = `${o}:calc(100${i} - ${a}rem)`, this.classNames[`${i}-max-${s}`] = `${l}:calc(100${i} - ${a}rem)`, this.classNames[`${i}-min-${s}%`] = `${o}:${a}${i}`, this.classNames[`${i}-max-${s}%`] = `${l}:${a}${i}`, 0 === a && (this.classNames[`${t[r]}-auto`] = `${e}:auto`, this.classNames[`${l}-auto`] = `${l}:auto`, this.classNames[`${t[r]}-full`] = `${e}:100%`, this.classNames[`${l}-full`] = `${l}:100%`, this.classNames[`${i}-${t[r]}-full`] = `${l}:100${i}`), a < 101 && (this.classNames[`${t[r]}-${s}%`] = `${e}:${s}%`, this.classNames[`${l}-${t[r]}%`] = `${l}:${s}%`) })), a > 0) { this.classNames[`text-${s}`] = `font-size:${a}rem;`, this.classNames[`lh-${s}`] = `line-height:${s};`, this.classNames[`lh-rem-${s}`] = `line-height:${a}rem;`; const e = (a / 16).toString().replace(/(^\d+\.\d{0,4}).*?$/, "$1"), t = e.replace(/\./g, "_"); this.classNames[`text-em-${t}`] = `font-size:${e}em;`, this.classNames[`text-rem-${t}`] = `font-size:${e}rem;` } const r = (e = [], t = null) => { if (t && t > s) return; let r = ""; for (let t = 0; t < 2; t++)r += "-", e.forEach((e => { const i = e?.[2] || !1, l = i ? s : a; let o = 0 == t ? l : -1 * l; const n = `${e[0]}${r}${s}${i ? "%" : ""}`; this.classNames[n] = e[1].replaceAll("{{s}}", o) })) }, i = ["p", "m"];["padding", "margin"].forEach(((s, e) => { const t = i[e]; r([[t, `${s}:{{s}}rem`], [`${t}x`, `${s}-left:{{s}}rem;${s}-right:{{s}}rem`], [`${t}y`, `${s}-top:{{s}}rem;${s}-bottom:{{s}}rem`], [`${t}t`, `${s}-top:{{s}}rem`], [`${t}b`, `${s}-bottom:{{s}}rem`], [`${t}l`, `${s}-left:{{s}}rem`], [`${t}r`, `${s}-right:{{s}}rem`]]) })), a < 33 && (this.classNames[`border-${s}`] = `border-width:${a}rem`), this.classNames[`rounded-${s}`] = `border-radius:${a}rem`, this.classNames[`rounded-t-${s}`] = `border-top-left-radius:${a}rem;border-top-right-radius:${a}rem`, this.classNames[`rounded-b-${s}`] = `border-bottom-left-radius:${a}rem;border-bottom-right-radius:${a}rem`, this.classNames[`rounded-l-${s}`] = `border-bottom-left-radius:${a}rem;border-top-left-radius:${a}rem;`, this.classNames[`rounded-r-${s}`] = `border-bottom-right-radius:${a}rem;border-top-right-radius:${a}rem;`, this.classNames[`rounded-tl-${s}`] = `border-top-left-radius:${a}rem`, this.classNames[`rounded-tr-${s}`] = `border-top-right-radius:${a}rem`, this.classNames[`rounded-bl-${s}`] = `border-bottom-left-radius:${a}rem`, this.classNames[`rounded-br-${s}`] = `border-bottom-right-radius:${a}rem`, ["inset", "top", "left", "right", "bottom"].forEach(((e, t) => { r([[e, `${e}:{{s}}%`, !0], [e, `${e}:{{s}}rem`]]), 0 === s && (this.classNames[`${e}-auto`] = `${e}:auto;`, this.classNames[`${e}-full`] = `${e}:100%;`) })) } ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"].forEach(((s, e) => { const t = 100 * (e + 1); this.classNames[`font-${s}`] = `font-weight:${t};` })), ["block", "flex", "grid", "table"].forEach((s => { const e = "-" + s; this.classNames[`${e}`] = `display:${s}`, this.classNames[`inline${e}`] = `display:inline${e}` })), this.classNames.row = "display:flex:flex-wrap:wrap;", this.classNames.col = "flex:1 0 0%"; for (let s = 1; s < 13; s++)this.classNames[`col-${s}`] = `flex:0 0 auto;width:${100 / 12}%`; const a = s => [Math.round(2 * s), Math.round(4 * s), Math.round(6 * s), Math.round(2 * s)], r = (s, e = 12) => { const [t, r, i, l] = a(s), [o, n, c, h] = a(s / 2), m = (e / 200).toString().replace(/(^\d+\.\d{0,2}).*?$/, "$1"); return `${t}rem ${r}rem ${i}rem ${l}rem rgba(0, 0, 0, ${m}), ${o}rem ${n}rem ${c}rem ${h}rem rgba(0, 0, 0, ${m})` }; for (let s = 0; s < 48; s++) { const e = "box-shadow:" + r(s); this.classNames[`elevation-${s}`] = e; for (let e = 0; e < 101; e++)this.classNames[`elevation-${s}-alpha-${e}`] = "box-shadow:" + r(s, e) } const i = Array.from(Array(12).keys()); for (let s = 0; s < i.length; s++) { const e = s > 0 ? `repeat(${s}, 1fr)` : "auto"; this.classNames[`grid-${s}`] = `grid-template-columns:${e}`; for (let t = 0; t < i.length; t++) { const a = t > 0 ? `repeat(${t}, 1fr)` : "auto"; this.classNames[`grid-${s}-${t}`] = `grid-template-columns:${e};grid-template-rows:${a}` } ["row", "column"].forEach((t => { const a = t.substring(0, 3); this.classNames[`${a}s-${s}`] = `grid-template-${t}s:${e}`; const r = s > 0 ? s : "auto"; this.classNames[`${a}-start-${s}`] = `grid-${t}-start:${r}`, this.classNames[`${a}-end-${s}`] = `grid-${t}-end:${r}`; const l = `span ${s}`; if (this.classNames[`grid-${a}-${s}`] = `grid-${t}:${s}`, s > 0) { this.classNames[`${a}-span-${s}`] = `grid-${t}-start:${l}`; for (let e = 1; e < i.length; e++) { const r = `span ${s}`; this.classNames[`${a}-${s}-${e}`] = `grid-${t}:${s}/${e}`, this.classNames[`${a}-span-${s}-${e}`] = `grid-${t}:${l}/${e}`, this.classNames[`${a}-${s}-span-${e}`] = `grid-${t}:${s}/${r}`, this.classNames[`${a}-span-${s}-span-${e}`] = `grid-${t}:${l}/${r}` } } })) } for (let s = 0; s < 96; s++)this.classNames[`gap-${s}`] = `gap:${s}rem`, this.classNames[`row-gap-${s}`] = `row-gap:${s}rem`, this.classNames[`column-gap-${s}`] = `column-gap:${s}rem`;["normal", "center", "flex-start", "flex-end", "space-between", "space-around", "space-evenly", "baseline", "stretch"].forEach((s => { const e = s.replace(/^(\w+\-)+(\w+)/, "$2"); this.classNames[`justify-${e}`] = `justify-content:${s}`, this.classNames[`content-${e}`] = `align-content:${s}`, this.classNames[`items-${e}`] = `align-items:${s}`, this.classNames[`justify-items-${e}`] = `justify-items:${s}` })), this.reponsiveAdd(), this.observer() } reponsiveAdd() { Object.keys(this.classNames).forEach((s => { this.classNamesList.add(s), this.sizes.map((s => s.code)).forEach((e => { this.classNamesList.add(`${e}:${s}`) })) })) } }, document.body && $observer.gotClassName(document.body);
